[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "StanBlocksAD.jl",
    "section": "",
    "text": "PROOF OF CONCEPT: A minimal performant reverse AD framework working on the AST level.\nSupports “Activity Analysis” and “Stateful Hand-Written Rules”. Does not support branches or loops."
  },
  {
    "objectID": "index.html#auto",
    "href": "index.html#auto",
    "title": "StanBlocksAD.jl",
    "section": "@auto",
    "text": "@auto\n“Automatically” define the standard (without duals), the forward and the reverse pass for a function. See usage in src/StanBlocksAD.jl.\n\nTrivial example: my_square\n\nMacro usageMacro expansion\n\n\n@auto @inline my_square(x) = return x * x\n\n\n\n\n\nquote\n    #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:381 =#\n    my_square(x) = begin\n            $(Expr(:meta, :inline))\n            #= In[3]:1 =#\n            return x * x\n        end\n    #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:382 =#\n    inner_forward(PB, _::AbstractDual{&lt;:typeof(my_square)}, x::AbstractDual{&lt;:Any}) = begin\n            $(Expr(:meta, :inline))\n            #= In[3]:1 =#\n            begin\n                #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:237 =#\n                (PB1, RV) = inner_forward(deaugment_pullback(PB[1]), maybeplaindual(*), maybeplaindual(x), maybeplaindual(x))\n                #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:238 =#\n                (PB1, RV) = augment_pullback(PB1, (maybeplaindual(*), maybeplaindual(x), maybeplaindual(x)), RV)\n            end\n            return (Tape((PB1,)), RV)\n        end\n    #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:383 =#\n    inner_pullback(PB, ADJ, _::AbstractDual{&lt;:typeof(my_square)}, x::AbstractDual{&lt;:Any}) = begin\n            $(Expr(:meta, :inline))\n            begin\n                #= In[3]:1 =#\n                RV = outer_replay(PB[1], *, x, x)\n                nothing\n                RV = ADJ\n                (_, x, x) = outer_pullback(PB[1], RV, *, x, x)\n                #= In[3]:1 =#\n            end\n            (StanBlocksAD.StrongZero(), x)\n        end\nend\n\n\n\n\n\n\n\n\nNontrivial example: StanBlocks.normal_lpdf\n\nMacro usageMacro expansion\n\n\n@auto @inline StanBlocks.normal_lpdf(y, loc, scale::Real) = begin\n    s2 = StanBlocks.@broadcasted square(y-loc)\n    return -(log(scale) * length(s2)+.5*my_sum(s2)/square(scale))\nend\n\n\n\n\n\nquote\n    #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:381 =#\n    StanBlocks.normal_lpdf(y, loc, scale::Real) = begin\n            $(Expr(:meta, :inline))\n            #= In[4]:1 =#\n            #= In[4]:2 =#\n            s2 = Base.broadcasted(square, Base.broadcasted(-, y, loc))\n            #= In[4]:3 =#\n            return -((log(scale) * length(s2) + (0.5 * my_sum(s2)) / square(scale)))\n        end\n    #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:382 =#\n    inner_forward(PB, _::AbstractDual{&lt;:typeof(StanBlocks.normal_lpdf)}, y::AbstractDual{&lt;:Any}, loc::AbstractDual{&lt;:Any}, scale::AbstractDual{&lt;:Real}) = begin\n            $(Expr(:meta, :inline))\n            #= In[4]:1 =#\n            #= In[4]:2 =#\n            begin\n                #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:237 =#\n                (PB1, TMP1) = inner_forward(deaugment_pullback(PB[1]), maybeplaindual(getproperty), maybeplaindual(Base), maybeplaindual(:broadcasted))\n                #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:238 =#\n                (PB1, TMP1) = augment_pullback(PB1, (maybeplaindual(getproperty), maybeplaindual(Base), maybeplaindual(:broadcasted)), TMP1)\n            end\n            begin\n                #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:237 =#\n                (PB2, TMP2) = inner_forward(deaugment_pullback(PB[2]), maybeplaindual(getproperty), maybeplaindual(Base), maybeplaindual(:broadcasted))\n                #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:238 =#\n                (PB2, TMP2) = augment_pullback(PB2, (maybeplaindual(getproperty), maybeplaindual(Base), maybeplaindual(:broadcasted)), TMP2)\n            end\n            begin\n                #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:237 =#\n                (PB3, TMP3) = inner_forward(deaugment_pullback(PB[3]), maybeplaindual(TMP2), maybeplaindual(-), maybeplaindual(y), maybeplaindual(loc))\n                #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:238 =#\n                (PB3, TMP3) = augment_pullback(PB3, (maybeplaindual(TMP2), maybeplaindual(-), maybeplaindual(y), maybeplaindual(loc)), TMP3)\n            end\n            begin\n                #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:237 =#\n                (PB4, s2) = inner_forward(deaugment_pullback(PB[4]), maybeplaindual(TMP1), maybeplaindual(square), maybeplaindual(TMP3))\n                #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:238 =#\n                (PB4, s2) = augment_pullback(PB4, (maybeplaindual(TMP1), maybeplaindual(square), maybeplaindual(TMP3)), s2)\n            end\n            #= In[4]:3 =#\n            begin\n                #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:237 =#\n                (PB5, TMP5) = inner_forward(deaugment_pullback(PB[5]), maybeplaindual(log), maybeplaindual(scale))\n                #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:238 =#\n                (PB5, TMP5) = augment_pullback(PB5, (maybeplaindual(log), maybeplaindual(scale)), TMP5)\n            end\n            begin\n                #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:237 =#\n                (PB6, TMP6) = inner_forward(deaugment_pullback(PB[6]), maybeplaindual(length), maybeplaindual(s2))\n                #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:238 =#\n                (PB6, TMP6) = augment_pullback(PB6, (maybeplaindual(length), maybeplaindual(s2)), TMP6)\n            end\n            begin\n                #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:237 =#\n                (PB7, TMP7) = inner_forward(deaugment_pullback(PB[7]), maybeplaindual(*), maybeplaindual(TMP5), maybeplaindual(TMP6))\n                #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:238 =#\n                (PB7, TMP7) = augment_pullback(PB7, (maybeplaindual(*), maybeplaindual(TMP5), maybeplaindual(TMP6)), TMP7)\n            end\n            begin\n                #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:237 =#\n                (PB8, TMP8) = inner_forward(deaugment_pullback(PB[8]), maybeplaindual(my_sum), maybeplaindual(s2))\n                #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:238 =#\n                (PB8, TMP8) = augment_pullback(PB8, (maybeplaindual(my_sum), maybeplaindual(s2)), TMP8)\n            end\n            begin\n                #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:237 =#\n                (PB9, TMP9) = inner_forward(deaugment_pullback(PB[9]), maybeplaindual(*), maybeplaindual(0.5), maybeplaindual(TMP8))\n                #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:238 =#\n                (PB9, TMP9) = augment_pullback(PB9, (maybeplaindual(*), maybeplaindual(0.5), maybeplaindual(TMP8)), TMP9)\n            end\n            begin\n                #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:237 =#\n                (PB10, TMP10) = inner_forward(deaugment_pullback(PB[10]), maybeplaindual(square), maybeplaindual(scale))\n                #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:238 =#\n                (PB10, TMP10) = augment_pullback(PB10, (maybeplaindual(square), maybeplaindual(scale)), TMP10)\n            end\n            begin\n                #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:237 =#\n                (PB11, TMP11) = inner_forward(deaugment_pullback(PB[11]), maybeplaindual(/), maybeplaindual(TMP9), maybeplaindual(TMP10))\n                #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:238 =#\n                (PB11, TMP11) = augment_pullback(PB11, (maybeplaindual(/), maybeplaindual(TMP9), maybeplaindual(TMP10)), TMP11)\n            end\n            begin\n                #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:237 =#\n                (PB12, TMP12) = inner_forward(deaugment_pullback(PB[12]), maybeplaindual(+), maybeplaindual(TMP7), maybeplaindual(TMP11))\n                #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:238 =#\n                (PB12, TMP12) = augment_pullback(PB12, (maybeplaindual(+), maybeplaindual(TMP7), maybeplaindual(TMP11)), TMP12)\n            end\n            begin\n                #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:237 =#\n                (PB13, RV) = inner_forward(deaugment_pullback(PB[13]), maybeplaindual(-), maybeplaindual(TMP12))\n                #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:238 =#\n                (PB13, RV) = augment_pullback(PB13, (maybeplaindual(-), maybeplaindual(TMP12)), RV)\n            end\n            return (Tape((PB1, PB2, PB3, PB4, PB5, PB6, PB7, PB8, PB9, PB10, PB11, PB12, PB13)), RV)\n        end\n    #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:383 =#\n    inner_pullback(PB, ADJ, _::AbstractDual{&lt;:typeof(StanBlocks.normal_lpdf)}, y::AbstractDual{&lt;:Any}, loc::AbstractDual{&lt;:Any}, scale::AbstractDual{&lt;:Real}) = begin\n            $(Expr(:meta, :inline))\n            begin\n                #= In[4]:1 =#\n                #= In[4]:2 =#\n                TMP1 = outer_replay(PB[1], getproperty, Base, :broadcasted)\n                TMP2 = outer_replay(PB[2], getproperty, Base, :broadcasted)\n                TMP3 = outer_replay(PB[3], TMP2, -, y, loc)\n                s2 = outer_replay(PB[4], TMP1, square, TMP3)\n                #= In[4]:3 =#\n                TMP5 = outer_replay(PB[5], log, scale)\n                TMP6 = outer_replay(PB[6], length, s2)\n                TMP7 = outer_replay(PB[7], *, TMP5, TMP6)\n                TMP8 = outer_replay(PB[8], my_sum, s2)\n                TMP9 = outer_replay(PB[9], *, 0.5, TMP8)\n                TMP10 = outer_replay(PB[10], square, scale)\n                TMP11 = outer_replay(PB[11], /, TMP9, TMP10)\n                TMP12 = outer_replay(PB[12], +, TMP7, TMP11)\n                RV = outer_replay(PB[13], -, TMP12)\n                nothing\n                RV = ADJ\n                (_, TMP12) = outer_pullback(PB[13], RV, -, TMP12)\n                (_, TMP7, TMP11) = outer_pullback(PB[12], TMP12, +, TMP7, TMP11)\n                (_, TMP9, TMP10) = outer_pullback(PB[11], TMP11, /, TMP9, TMP10)\n                (_, scale) = outer_pullback(PB[10], TMP10, square, scale)\n                (_, _, TMP8) = outer_pullback(PB[9], TMP9, *, 0.5, TMP8)\n                (_, s2) = outer_pullback(PB[8], TMP8, my_sum, s2)\n                (_, TMP5, TMP6) = outer_pullback(PB[7], TMP7, *, TMP5, TMP6)\n                (_, s2) = outer_pullback(PB[6], TMP6, length, s2)\n                (_, scale) = outer_pullback(PB[5], TMP5, log, scale)\n                #= In[4]:3 =#\n                (TMP1, _, TMP3) = outer_pullback(PB[4], s2, TMP1, square, TMP3)\n                (TMP2, _, y, loc) = outer_pullback(PB[3], TMP3, TMP2, -, y, loc)\n                (_, _, _) = outer_pullback(PB[2], TMP2, getproperty, Base, :broadcasted)\n                (_, _, _) = outer_pullback(PB[1], TMP1, getproperty, Base, :broadcasted)\n                #= In[4]:2 =#\n                #= In[4]:1 =#\n            end\n            (StanBlocksAD.StrongZero(), y, loc, scale)\n        end\nend"
  },
  {
    "objectID": "index.html#overlay",
    "href": "index.html#overlay",
    "title": "StanBlocksAD.jl",
    "section": "@overlay",
    "text": "@overlay\nDoes the same thing as @auto, but doesn’t define the “standard” function (without duals), like Mooncake.@mooncake_overlay. Useful for manually (hah!) doing AD for functions from external packages.\nSee usage in src/StanBlocksAD.jl.\n\nExample: Base.sum(x::Float64)\n\nMacro usageMacro expansion\n\n\n@overlay @inline Base.sum(x::Float64) = return identity(x)\n\n\n\n\n\nquote\n    #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:386 =#\n    inner_forward(PB, _::AbstractDual{&lt;:typeof(Base.sum)}, x::AbstractDual{&lt;:Float64}) = begin\n            $(Expr(:meta, :inline))\n            #= In[5]:1 =#\n            begin\n                #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:237 =#\n                (PB1, RV) = inner_forward(deaugment_pullback(PB[1]), maybeplaindual(identity), maybeplaindual(x))\n                #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:238 =#\n                (PB1, RV) = augment_pullback(PB1, (maybeplaindual(identity), maybeplaindual(x)), RV)\n            end\n            return (Tape((PB1,)), RV)\n        end\n    #= /home/niko/github/nsiccha/StanBlocksAD.jl/src/StanBlocksAD.jl:387 =#\n    inner_pullback(PB, ADJ, _::AbstractDual{&lt;:typeof(Base.sum)}, x::AbstractDual{&lt;:Float64}) = begin\n            $(Expr(:meta, :inline))\n            begin\n                #= In[5]:1 =#\n                RV = outer_replay(PB[1], identity, x)\n                nothing\n                RV = ADJ\n                (_, x) = outer_pullback(PB[1], RV, identity, x)\n                #= In[5]:1 =#\n            end\n            (StanBlocksAD.StrongZero(), x)\n        end\nend"
  },
  {
    "objectID": "index.html#rule",
    "href": "index.html#rule",
    "title": "StanBlocksAD.jl",
    "section": "@rule",
    "text": "@rule\nThe @rule macro makes it “easy” to define hand-written rules. It does funky things behind the scenes, and handles some function definition right hand sides in a special way. Best understood by looking at examples and simultaneously talking to me.\nSee usage at src/StanBlocksAD.jl.\nSOMETHING IMPORTANT IS MISSING, WILL ADD LATER.\n\nTrivial examples\n\nMacro usageMacro expansion\n\n\n@rule begin \n    # No pullback.\n    @inline inner_forward(pb, f::Colon, i, j) = nothing\n    # Custom @inline'd pullback, \"standard\" forward pass \n    @inline inner_forward(pb, f::typeof(identity), x) = (a, df, dx)-&gt;(df, dx + a)\n    # Custom @inline'd pullback, \"standard\" forward pass. Uses non-captured but recomputed primal information in pullback.\n    @inline inner_forward(pb, f::typeof(getproperty), x, i::Symbol) = (a, df, dx, di) -&gt; (df, dmergeproperty(dx, a, primal(di)), di)\n    # Custom pullback and forward pass.\n    @inline inner_forward(pb, f::typeof(/), x, y) = begin\n        rv = f(x,y)\n        (a, df, dx, dy) -&gt; (df, dx+a/y, dy-a*rv/y), rv\n    end\nend\n\n\n\n\n\nquote\n    #= In[6]:3 =#\n    begin\n        inner_forward(pb::Any, f::AbstractDual{&lt;:Colon}, i::AbstractDual{&lt;:Any}, j::AbstractDual{&lt;:Any}) = begin\n                $(Expr(:meta, :inline))\n                #= In[6]:3 =#\n                (nothing, plaindual((primal(f))(primal(i), primal(j))))\n            end\n        inner_forward(pb::Any, f::AbstractPlainDual{&lt;:Colon}, i::AbstractPlainDual{&lt;:Any}, j::AbstractPlainDual{&lt;:Any}) = begin\n                $(Expr(:meta, :inline))\n                (nothing, plaindual((primal(f))(primal(i), primal(j))))\n            end\n    end\n    #= In[6]:5 =#\n    begin\n        inner_forward(pb::Any, f::AbstractDual{&lt;:typeof(identity)}, x::AbstractDual{&lt;:Any}) = begin\n                $(Expr(:meta, :inline))\n                #= In[6]:5 =#\n                (((a, df, dx)-&gt;begin\n                            $(Expr(:meta, :inline))\n                            #= In[6]:5 =#\n                            (df, dx + a)\n                        end), (primal(f))(primal(x)))\n            end\n        inner_forward(pb::Any, f::AbstractPlainDual{&lt;:typeof(identity)}, x::AbstractPlainDual{&lt;:Any}) = begin\n                $(Expr(:meta, :inline))\n                (nothing, plaindual((primal(f))(primal(x))))\n            end\n    end\n    #= In[6]:7 =#\n    begin\n        inner_forward(pb::Any, f::AbstractDual{&lt;:typeof(getproperty)}, x::AbstractDual{&lt;:Any}, i::AbstractDual{&lt;:Symbol}) = begin\n                $(Expr(:meta, :inline))\n                #= In[6]:7 =#\n                (((a, df, dx, di)-&gt;begin\n                            $(Expr(:meta, :inline))\n                            #= In[6]:7 =#\n                            (df, dmergeproperty(dx, a, primal(di)), di)\n                        end), (primal(f))(primal(x), primal(i)))\n            end\n        inner_forward(pb::Any, f::AbstractPlainDual{&lt;:typeof(getproperty)}, x::AbstractPlainDual{&lt;:Any}, i::AbstractPlainDual{&lt;:Symbol}) = begin\n                $(Expr(:meta, :inline))\n                (nothing, plaindual((primal(f))(primal(x), primal(i))))\n            end\n    end\n    #= In[6]:9 =#\n    begin\n        inner_forward(pb::Any, f::AbstractDual{&lt;:typeof(/)}, x::AbstractDual{&lt;:Any}, y::AbstractDual{&lt;:Any}) = begin\n                $(Expr(:meta, :inline))\n                #= In[6]:9 =#\n                #= In[6]:10 =#\n                rv = (primal(f))(primal(x), primal(y))\n                #= In[6]:11 =#\n                (((a, df, dx, dy)-&gt;begin\n                            #= In[6]:11 =#\n                            (df, dx + a / primal(y), dy - (a * rv) / primal(y))\n                        end), rv)\n            end\n        inner_forward(pb::Any, f::AbstractPlainDual{&lt;:typeof(/)}, x::AbstractPlainDual{&lt;:Any}, y::AbstractPlainDual{&lt;:Any}) = begin\n                $(Expr(:meta, :inline))\n                (nothing, plaindual((primal(f))(primal(x), primal(y))))\n            end\n    end\nend\n\n\n\n\n\n\n\n\nNon-trivial example: my_sum\n\nMacro usageMacro expansion\n\n\n@rule @inline inner_forward(pb, f::typeof(my_sum), x::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}}) = begin \n    mem = if isa(pb, Tape{Missing})\n        pb_type = Base._return_type(outer_forward, Tuple{Tape{Missing},typeof(broadcast_getindex),typeof(dual(x)),Int64})\n        @assert isconcretetype(pb_type) outer_forward(Tape(), broadcast_getindex, dual(x), 1)\n        pb_type = pb_type.types[1]\n        Vector{pb_type}(undef, length(x))\n    else\n        resize!(pb.mem, length(x))\n    end\n    rv = 0.\n    (mem[1], drv) = outer_forward(Tape(), broadcast_getindex, dual(x), 1)\n    rv = primal(drv)\n    @inbounds @simd for i in eachindex(x)[2:end]\n        (mem[i], drv) = outer_forward(Tape(), broadcast_getindex, dual(x), i)\n        rv += primal(drv)\n    end\n    sum_pb(a, df, dx) = begin \n        (_, dx, _) = outer_pullback(mem[1], a, broadcast_getindex, dx, 1)\n        @inbounds @simd for i in eachindex(mem)[2:end]\n            (_, dx, _) = outer_pullback(mem[i], a, broadcast_getindex, dx, i) \n        end\n        (df, dx)\n    end\n    sum_pb, (rv)\nend\n\n\n\n\n\nquote\n    inner_forward(pb::Any, f::AbstractDual{&lt;:typeof(my_sum)}, x::AbstractDual{&lt;:Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}}}) = begin\n            $(Expr(:meta, :inline))\n            #= In[7]:1 =#\n            #= In[7]:2 =#\n            mem = if pb isa Tape{Missing}\n                    #= In[7]:3 =#\n                    pb_type = Base._return_type(outer_forward, Tuple{Tape{Missing}, typeof(broadcast_getindex), typeof(x), Int64})\n                    #= In[7]:4 =#\n                    if isconcretetype(pb_type)\n                        nothing\n                    else\n                        Base.throw(Base.AssertionError((Base.Main).Base.string(outer_forward(Tape(), broadcast_getindex, x, 1))))\n                    end\n                    #= In[7]:5 =#\n                    pb_type = pb_type.types[1]\n                    #= In[7]:6 =#\n                    Vector{pb_type}(undef, length(primal(x)))\n                else\n                    #= In[7]:8 =#\n                    resize!(pb.mem, length(primal(x)))\n                end\n            #= In[7]:10 =#\n            rv = 0.0\n            #= In[7]:11 =#\n            (mem[1], drv) = outer_forward(Tape(), broadcast_getindex, x, 1)\n            #= In[7]:12 =#\n            rv = primal(drv)\n            #= In[7]:13 =#\n            begin\n                $(Expr(:inbounds, true))\n                local var\"#105#val\" = begin\n                            #= simdloop.jl:69 =#\n                            let var\"##r#225\" = (eachindex(primal(x)))[2:end]\n                                #= simdloop.jl:70 =#\n                                for var\"##i#226\" = Base.simd_outer_range(var\"##r#225\")\n                                    #= simdloop.jl:71 =#\n                                    let var\"##n#227\" = Base.simd_inner_length(var\"##r#225\", var\"##i#226\")\n                                        #= simdloop.jl:72 =#\n                                        if zero(var\"##n#227\") &lt; var\"##n#227\"\n                                            #= simdloop.jl:74 =#\n                                            let var\"##i#228\" = zero(var\"##n#227\")\n                                                #= simdloop.jl:75 =#\n                                                while var\"##i#228\" &lt; var\"##n#227\"\n                                                    #= simdloop.jl:76 =#\n                                                    local i = Base.simd_index(var\"##r#225\", var\"##i#226\", var\"##i#228\")\n                                                    #= simdloop.jl:77 =#\n                                                    begin\n                                                        #= In[7]:14 =#\n                                                        (mem[i], drv) = outer_forward(Tape(), broadcast_getindex, x, i)\n                                                        #= In[7]:15 =#\n                                                        rv += primal(drv)\n                                                        #= In[7]:16 =#\n                                                    end\n                                                    #= simdloop.jl:78 =#\n                                                    var\"##i#228\" += 1\n                                                    #= simdloop.jl:79 =#\n                                                    $(Expr(:loopinfo, Symbol(\"julia.simdloop\"), nothing))\n                                                    #= simdloop.jl:80 =#\n                                                end\n                                            end\n                                        end\n                                    end\n                                    #= simdloop.jl:84 =#\n                                end\n                            end\n                            #= simdloop.jl:86 =#\n                            nothing\n                        end\n                $(Expr(:inbounds, :pop))\n                var\"#105#val\"\n            end\n            #= In[7]:17 =#\n            sum_pb(a, df, dx) = begin\n                    #= In[7]:17 =#\n                    #= In[7]:18 =#\n                    (_, dx, _) = outer_pullback(mem[1], a, broadcast_getindex, dx, 1)\n                    #= In[7]:19 =#\n                    begin\n                        $(Expr(:inbounds, true))\n                        local var\"#106#val\" = begin\n                                    #= simdloop.jl:69 =#\n                                    let var\"##r#229\" = (eachindex(mem))[2:end]\n                                        #= simdloop.jl:70 =#\n                                        for var\"##i#230\" = Base.simd_outer_range(var\"##r#229\")\n                                            #= simdloop.jl:71 =#\n                                            let var\"##n#231\" = Base.simd_inner_length(var\"##r#229\", var\"##i#230\")\n                                                #= simdloop.jl:72 =#\n                                                if zero(var\"##n#231\") &lt; var\"##n#231\"\n                                                    #= simdloop.jl:74 =#\n                                                    let var\"##i#232\" = zero(var\"##n#231\")\n                                                        #= simdloop.jl:75 =#\n                                                        while var\"##i#232\" &lt; var\"##n#231\"\n                                                            #= simdloop.jl:76 =#\n                                                            local i = Base.simd_index(var\"##r#229\", var\"##i#230\", var\"##i#232\")\n                                                            #= simdloop.jl:77 =#\n                                                            begin\n                                                                #= In[7]:20 =#\n                                                                (_, dx, _) = outer_pullback(mem[i], a, broadcast_getindex, dx, i)\n                                                                #= In[7]:21 =#\n                                                            end\n                                                            #= simdloop.jl:78 =#\n                                                            var\"##i#232\" += 1\n                                                            #= simdloop.jl:79 =#\n                                                            $(Expr(:loopinfo, Symbol(\"julia.simdloop\"), nothing))\n                                                            #= simdloop.jl:80 =#\n                                                        end\n                                                    end\n                                                end\n                                            end\n                                            #= simdloop.jl:84 =#\n                                        end\n                                    end\n                                    #= simdloop.jl:86 =#\n                                    nothing\n                                end\n                        $(Expr(:inbounds, :pop))\n                        var\"#106#val\"\n                    end\n                    #= In[7]:22 =#\n                    (df, dx)\n                end\n            #= In[7]:24 =#\n            (sum_pb, rv)\n        end\n    inner_forward(pb::Any, f::AbstractPlainDual{&lt;:typeof(my_sum)}, x::AbstractPlainDual{&lt;:Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}}}) = begin\n            $(Expr(:meta, :inline))\n            (nothing, plaindual((primal(f))(primal(x))))\n        end\nend"
  }
]